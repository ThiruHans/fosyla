%-----------------------------------------------
% DOCUMENT PACKAGES
%-----------------------------------------------
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[margin=1.3in]{geometry}
\usepackage{hyperref}
\usepackage[french]{babel}
\usepackage[small, sc, bf, center]{titlesec}
\usepackage{listings}
\usepackage{amsmath, amssymb, mathtools}
\usepackage{cleveref}
\usepackage[table]{xcolor}
\usepackage{fancyhdr}
\usepackage{tikz}
\usepackage{tkz-graph}
\usepackage{csvsimple}
%\usepackage{subcaption}
%\usepackage{multicol}
\usepackage{csquotes}
\usepackage{tikz-uml}
%-----------------------------------------------
% DOCUMENT CONFIG
%-----------------------------------------------

% Add point after title number
\titleformat{\section}[block]{\sc\bfseries\center\large}{\thesection.}{0.5em}{}
\titleformat{\subsection}[block]{\sc\bfseries\center}{\thesubsection.}{0.5em}{}
\titleformat{\subsubsection}[block]{\sc\bfseries\center}{\thesubsubsection.}{0.5em}{}
% Page number reformat
\pagestyle{fancy}
\fancyfoot[C]{--~\thepage~--}
% Deactivate fancyhdr header
\renewcommand{\headrulewidth}{0pt}
\fancyhead{}
% tikz
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=6pt]
\newcommand{\vertex}{\node[vertex]}
\usetikzlibrary{arrows,petri,topaths,calc}
% listing style
\lstset{
frame=single,
basicstyle=\ttfamily\small,
numbers=left,
%numbersep=5pt,
%font=\ttfamily
}

%-----------------------------------------------
% DOCUMENT BODY
%-----------------------------------------------
\begin{document}
	
\begin{center}
	\textbf{Projet de FOSYMA\\[.5cm]Wumpus Multi-Agent}\\[.5cm]
	\textit{Alexandre Bontems, Hans Thirunavukarasu}\\
\end{center}

\tableofcontents
\section{Introduction}
Une version multi-agent du jeu \textquote{Hunt the Wumpus} est implémentée dans ce projet. On y considère une carte de labyrinthe sous forme de graphe dans laquelle certains sommets présentent des trésors. Ceux-ci peuvent être de deux types, trésors ou diamants, et présents en une quantité prédéfinie. Les agents évoluent dans cette carte en s'y déplaçant: passer d'un sommet $v_1$ à un sommet $v_2$ n'est permis que si l'arête $(v_1, v_2)$ existe dans le graphe. De plus, chaque agent occupe un sommet du graphe à tout moment et plusieurs agents ne peuvent occuper un même sommet. Les déplacements sont donc susceptibles d'être bloqués si le sommet de destination est déjà occupé.

Le but final du jeu est d'explorer entièrement le graphe et de récupérer tous les trésors qui s'y trouvent. Pour cela on dispose de plusieurs types d'agents : explorateurs, collecteurs et silo. Les explorateurs ont pour fonctions d'explorer la carte et de reporter la position des trésors. Les collecteurs possèdent un sac-à-dos pouvant contenir une certaine capacité d'un seul type de trésor et peuvent ramasser les trésors de ce type qui se trouvent à leur position. Le ramassage n'est pas parfait cependant puisqu'à chaque tentative un partie du trésor présent sur le sommet est perdue à jamais. Enfin le silo possède une capacité illimitée pour tous les types de trésors et les collecteurs peuvent donc lui donner le contenu de leur sac-à-dos lorsqu'il est plein.

Le \textit{wumpus}, un agent adverse, est lui aussi déployé dans la carte. Son déplacement est aléatoire mais il est capable de déplacer des trésors sur la carte et d'en réduire ainsi la quantité totale définitivement. Il est lui aussi sujet aux restrictions décrites ci-dessus.

Dans ce rapport, l'exploration est d'abord abordée, comportement susceptible d'être adopté par tout agent quelque soit sont type. Tous les thèmes liés à la coordination tels que les communications, la gestion des interblocages et le ramassage de trésor sont ensuite décrit.
\section{Exploration}
Le comportement d'exploration a été le premier à être implémenté en raison de son indispensabilité. En effet, tout autre comportement ne peut être fonctionnel que si l'environnement de l'agent est connu. C'est aussi le comportement par défaut de tous les agents lorsqu'ils n'ont pas d'objectif plus pressant. Au lancement de l'exécution par exemple, les collecteurs ne connaissent pas les positions des trésors ni du silo et pour les découvrir on passe en mode d'exploration. Pour la même raison, le silo ne connaissant pas la position des autres agents, se tourne d'abord vers une phase d'exploration.

Puisque l'environnement est modélisé sous forme de graphe, il est naturel pour le parcourir entièrement de se tourner vers un comportement inspiré de Breadth First Search (BFS). Ainsi trois structures de données sont utilisées: premièrement, la carte est sauvée en tant que listes de voisins (\texttt{HashMap<String, HashSet<String>{}>} en java) et associe à chaque sommet ses voisins dans le graphe. Un ensemble de sommets ouverts est aussi maintenu: ce sont les sommets encore non explorés. Enfin un ensemble de sommets déjà explorés est gardé en mémoire. Chaque agent en mode d'exploration construit donc une carte en choisissant le sommet ouvert le plus proche et en l'ajoutant à la carte (lui et ses voisins)  lorsqu'il est atteint. Les chemins jusqu'à un sommet sont calculés par BFS depuis le sommet de départ et le sommet ouvert le plus proche est donc celui pour lequel le chemin est le plus court. À chaque choix de sommet de destination on a donc une complexité de $O(n + m)$ pour le BFS et une carte de $n$ sommets et $m$ arêtes.

Lorsque l'exploration est finie, i.e. un agent n'a plus de sommets ouverts, les agents explorant ont plusieurs options. Tout d'abord, lors des phases de communication (voir \Cref{sec-comm}) les agents se mettent d'accord sur l'identité de l'explorateur dit de \textquote{mise à jour des points d'intérêts}. Cet agent aura pour mission, lorsqu'il a terminé son exploration, de se déplacer entre chaque sommet connu comme contenant un trésor afin d'avoir la représentation la plus récente possible de chaque trésor de la carte. Il lui sera ainsi possible lors des rencontres de partager cette information. Les autres agents quant à eux relancent une exploration complète de la carte en \textquote{oubliant} quels sommets ont déjà été visités. Cela est nécessaire puisque le \textit{wumpus} est capable de déplacer des trésors et il est donc important de repasser par tous les sommets pour détecter les nouveaux points d'intérêt. L'agent de mise à jour choisit donc le point d'intérêt le plus ancien, planifie un chemin pour s'y rendre et lorsque ce point est atteint passe au prochain point le plus ancien. Un comportement sensiblement plus intelligent serait de concentrer l'exploration dans le voisinage des points d'intérêt déjà connus car le \textit{wumpus} a seulement une faible portée de déplacement. Cependant, dans un soucis d'optimisation des interblocages et par manque de temps, ce comportement n'est pas implémenté.

Lorsque deux agents se rencontrent les cartes peuvent être échangées et aucune vérification n'est nécessaire car la carte ne peut pas évoluer dans le temps. La liste des trésors cependant est changeante et c'est pourquoi à tout point d'intérêt est associée une date d'observation. Lors des communications les agents sont ainsi capables de comparer les dates et de distinguer l'observation la plus récente. Ils utilisent pour cela l'horloge système de la machine sur laquelle ils sont lancés.
\section{Coordination}

Qui dit simulation multi-agent dit calcul distribué et donc un besoin primordial de communication entre processus. Chaque agent est ainsi capable d'échanger des messages avec d'autres agents aux travers d'un réseau (ces messages utilisent la norme FIPA). Ces communications forment la fondation des différents comportements de coordination qui sont décrit par la suite.

\subsection{Communication}
\label{sec-comm}

Pour pouvoir expliquer plus en avant les communications inter-agent il est nécessaire d'introduire la machine à états qui les régit. Visible en~\Cref{fig-fsm}, la machine et ses transitions sont expliquées ici. On y voit que le premier état atteint est bien celui de l'exploration mais il est surtout important de pointer du doigt l'état central \textsf{CheckVoiceMail}. C'est grâce à lui que les agents sont capables de s'écouter et se parler. En effet après chaque mouvement, chacun vérifie dans sa boîte aux lettres qu'aucun message n'a été reçu. En parallèle des données transitent entre nos differents comportements grâce a un DataStore pour pouvoir transmettre la situation actuelle de l'agent. Ainsi, des flags sont contenu dans ce DataStore et sont utilisés pour permettre le bon redirigement lorsque l'on est dans \textsf{CheckVoiceMail}. Tout d'abord si l'agent a reçu un message de type Request dans sa boite mail, cela signifie qu'un autre agent lui a demandé de s'arrêter, il envois donc un message ACK à cet agent et passe à l'état \textsf{SendData} dans lequel il va envoyer les informations de sa carte. Cette étape est nécessaire pour établir la communication entre nos deux agents car rappelons le, les deux doivent être immobile pour entamer une communication. En revanche si aucun message n'a été reçu, on regarde alors si le flag \textquote{block notification} de notre agent est a true pour enclencher une procédure de communication avec l'autre agent qui nous bloque. Nous passons ainsi à l'état \textsf{RequestStandby} dans lequel l'agent enverra un message de type Request en \textquote{Broadcast} car il ne connait pas forcément l'agent qui le bloque. Enfin toujours lorsque l'on est dans \textsf{CheckVoiceMail}, si aucun message n'a été reçu et que l'agent n'était pas bloqué, alors il retourne dans l'un  des quatre comportements de déplacement suivant : \textsf{Explore}, \textsf{AvoidConflict}, \textsf{RandomWalk} ou \textsf{TypeSpecificMvmt}. En effet, toujours à l'aide des flags contenu dans notre DataStore, l'agent est redirigé vers le bon comportement. Par exemple il existe un flag \textquote{avoid conflict} qui est potentiellement mis à true lorsque l'on est dans l'état \textsf{RcvGoal}, or de \textsf{RcvGoal} nous retournons à \textsf{CheckVoiceMail}, qui redirigera donc notre agent vers le comportement \textsf{AvoidConflict} en adéquation avec la valeur booléenne true de notre flag.

\begin{figure}[ht!]
    \centering
    \begin{tikzpicture}
    \umlstateinitial[x=-2, name=initial]
    \umlbasicstate[x=-2, y=-2.3, fill=red!20]{Explore}
    \umlbasicstate[y=-6, fill=blue!20]{CheckVoiceMail}
    \umlbasicstate[y=-6, x=4.4]{RequestStandby}
    \umlbasicstate[y=-6, x=9]{WaitForStandby}
    \umlbasicstate[x=-1, y=-10]{SendData}
    \umlbasicstate[y=-10, x=2.5]{RcvData}
    \umlbasicstate[y=-10, x=6]{SendGoal}
    \umlbasicstate[y=-10, x=9.5]{RcvGoal}
    \umlbasicstate[x=1.3, y=-2, fill=red!20]{AvoidConflict}
    \umlbasicstate[x=5.1, y=-2, fill=red!20]{RandomWalk}
    \umlbasicstate[x=9.3, y=-2, fill=red!20]{TypeSpecificMvmt}
    
    \umltrans{initial}{Explore}
    \umlVHVtrans[anchors=south and 140]{Explore}{CheckVoiceMail}
    \umlVHVtrans[anchors=140 and south]{CheckVoiceMail}{Explore}
    \umltrans{CheckVoiceMail}{RequestStandby}
    \umltrans{RequestStandby}{WaitForStandby}
    \umlVHVtrans{WaitForStandby}{SendData}
    \umlVHVtrans[anchors=north and 40, arm1=0.5cm]{WaitForStandby}{CheckVoiceMail}
    \umlVHVtrans[anchor2=120, anchor1=-120, arm1=-0.5cm]{CheckVoiceMail}{SendData}
    \umltrans{SendData}{RcvData}
    \umltrans{RcvData}{SendGoal}
    \umlVHVtrans[anchor2=-60, arm1=1.5cm]{RcvData}{CheckVoiceMail}
    \umltrans{SendGoal}{RcvGoal}
    \umlVHVtrans[anchor2=-40, arm1=2.5cm]{RcvGoal}{CheckVoiceMail}
    \umlVHVtrans[anchors=-135 and 120, arm1=-0.4cm]{AvoidConflict}{CheckVoiceMail}
    \umlVHVtrans[anchors=120 and -135, arm2=-0.4cm]{CheckVoiceMail}{AvoidConflict}
    \umlVHVtrans[anchors=-135 and 100, arm1=-0.7cm]{RandomWalk}{CheckVoiceMail}
    \umlVHVtrans[anchors=100 and -135, arm2=-0.7cm]{CheckVoiceMail}{RandomWalk}
    \umlVHVtrans[anchors=-135 and 80, arm1=-1cm]{TypeSpecificMvmt}{CheckVoiceMail}
    \umlVHVtrans[anchors=80 and -135, arm2=-1cm]{CheckVoiceMail}{TypeSpecificMvmt}
    \end{tikzpicture}
    \caption{Machine à états finie des agents.}
    \label{fig-fsm}
\end{figure}

\subsection{Interblocage}

Deux grosses situations se dégagent donc de notre machine à états lors d'un interblocage. La première, notre agent reçoit une requete de Standby d'un autre agent et la deuxieme, notre agent envoie une requete de Standby aux autres agents. L'éxécution étant concurrente et l'envois de messages étant asynchrone, tout dépends donc du premier agent à detecter l'interblocage. Si notre agent est le premier a le detecter (cet-à-dire que la fonction moveTo de Jade renvoie false) alors le flag \textquote{block notification} est mis à true et lorsque l'on arrive dans \textsf{CheckVoiceMail}, on est alors redirigé vers l'état \textsf{RequestStandby}. Après avoir envoyé sa requête en \textquote{Broadcast}, il passe ensuite à l'état \textsf{WaitStandby} où il attend confirmation de l'autre agent. S'il reçoit le ACK ( s'il ne le reçoit pas, il est redirigé vers l'état central) , il passe à l'état \textsf{SendData} qui est donc le début de la communication entre les deux agents. Il envoit donc ses données de la carte, et attends celles de l'autre agent à l'état \textsf{RcvData}. Enfin les deux agents s'échangent leur destination et leur chemin pour pouvoir résoudre l'interblocage via les états \textsf{SendGoal} et textsf{RcvGoal} , similaires aux deux états précèdents. Plus précisément, c'est dans l'état \textsf{RcvGoal} que se décide comment sera gerer l'interblocage. En effet, les deux agents ayant maintenant donc connaissance de la même carte, et le goal de l'autre agent, ils peuvent donc se mettre d'accord sur l'action à faire par la suite. L'interblocage est donc déroulé de cette façon : les deux agents calculent leur \textquote{escape route}, cet à dire qu'ils vont regarder dans le chemin de l'autre, la premiere node où il est possible de s'échapper pour pouvoir laisser le passage (concrètement, on regarde parmis les noeuds voisins du chemin , s'il existe un noeud qui n'en fait pas partie et qui est accessible). Ainsi si l'un des deux agents ne trouve pas de \textquote{escape route}, il aura donc la priorité et l'autre agent devra donc lui laisser le passage. Cet agent aura donc le flag \textquote{avoid conflict} à true ce qui lui permettra d'être rediriger vers le comportement \textsf{AvoidConflic} où il executera son \textquote{escape route} tandis que l'agent ne pouvant pas s'échapper, attendra tout simplement que l'autre agent se déplace. Par ailleurs, si les deux agents trouvent des chemins pour s'échapper, alors celui avec le chemin le plus cours devra se deplacer et laisser le passage à l'autre, tout ça dans le but de régler l'interblocage le plus rapidement possible.

\subsection{Ramassage de trésor}
\subsection{Placement du Silo}
\section{Conclusion}

\end{document}